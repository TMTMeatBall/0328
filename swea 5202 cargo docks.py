# 최대한 많은 회의 최대한 많은 미팅 사용시간이 끝나는 시간이 빠른 순으로 전부 sort 한 뒤에 가장 일찍 시작하는 하나를 픽업하고,
# 그것이 끝나는 시간보다 일찍 시작하는 것들을 모두 제외하고, 남은 것들 중 가장 먼저 시작하는 것을 다음으로 픽업하고 계속 이것을 리스트 끝까지 반복한다.
# 종료 시간과 시작 시간이 같은 경우도 가능한 것으로 본다
# 그리디 알고리즘으로 해결한다
# 시간을 이차원배열로 받고 해결합시다...
# 최대 몇 번의 활동이 가능한지를 계산하시오


T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    result = 0

    times = [list(map(int, input().split())) for _ in range(N)]

    times.sort(key=lambda x: x[1])  # 람다 key를 사용해서 종료 시간으로 이차원배열을 sort

    a = 0
    b = len(times)
    e = 0 #종료시간만 비교변수로 사용하므로

    while a < b: #나열된 시간표의 가장 앞부터 뒤까지 반복하면서,
        if times[a][0] >= e: #times[a][0] = 시작시간
            result += 1 #작업수로 가능한 경우엔 +1
            e = times[a][1] #새로운 마지막 작업의 종료시간을 받음
        a += 1 #다음 시작시간을 받기 위해 +1

    print(f'#{tc} {result}')