# def combination(n,r):
#     if r == 0:
#         print(arr)
#     elif n < r :
#     return
#
#     else:
#         tr[r-1] = an[n-1]
#         combnation(n-1,r-1)
#         combination(n-1,r) nCr = n-1Cr-1 + n-1Cr
#

# combination(10,3)의 코드 구현(for 구문 반복)
# N = 10
# for i in range(N-2):
#     for j in range(i+1,N-1):
#         for k in range(j+1,N):
#             print(i,j,k)
#


# 2) 재귀를 통한 combination 구현
# def nCr(n, r, s):
#     global cnt
#     if r == 0:
#
#         print(comb)
#     else:
#         for i in range(s, n - r + 1):
#             comb[r - 1] = A[i]
#
#             nCr(n, r - 1, i + 1) 재귀적으로 자신을 호출하게 된다. 최대 r만큼 자신을 호출함.
#
# cnt=0
# n = 100
# r = 99
# comb = [0] * 3
# A = [i for i in range(n)]
# nCr(100, 3, 0)

# 아래의 10개의 정수 집합에 대한 모든 부분집합 중 원소의 합이 0이 되는 부분집합을 모두 출력하시오
# 예 {-1,3,-9,6,7,-6,1,5,4,-2}
# 재귀적으로 자신을 호출할 것 / 깊이값 i에 해당되는 원소를 부분집합에 포함하면 1을 그렇지 않다면 0을
def f(i, k):

    if i == k: #기저조건(스톱하는 순간) i=0부터 i+1--i+2--i+3--i+4--i+5....하다가 i==k는
        sum = 0
        for i in range(N):
            if bit[i] == 1:
                sum += A[i] #bit[i]==1이면 그 idx는 A의 부분집합에 포함하는 것이므로 sum += A[i]한다

        if sum == 0:
            for i in range(N):
                if bit[i] == 1:
                    print(A[i],end=' ')
            print()
    else:
        bit[i] = 0
        f(i + 1, k)
        bit[i] = 1
        f(i + 1, k)


A = [-1, 3, -9, 6, 7, -6, 1, 5, 4, -2]
N = len(A)
bit = [0] * N

f(0, N)

#2
# for i in range(0,1 << N):
#     for j in range(0,N):
#         if i & (1<<j):
#             sum += A[j]
#     if sum == 0:
#         for j in range(0,N):
#             if i & (1 <<j):
#                 print(A[j],end=' ')
#         print()


# swea의 learning course advanced....


# 탐욕적인 알고리즘
# 탐욕적으로 접근하기 쉬운 경우의 문제들이 존재함...
# knapsack(배낭 짐싸기 문제)
# 무게를 초과하지 않으면서, 가장 가치가 높게 챙기는 방법을 찾아보자
# 0-1(zero-one)knapsack - 물건쪼개기가 불가능한 유형
# fractional knapsack - 물건을 부분적으로 담거나 쪼개기가 가능한 유형

# 완전 검색으로 모든 부분집합을 버리고, 총무게가 W를 초과하는 집합은 버리고, 나머지 집합 중에서
# 가치가 가장 높은 부분집합을 정답으로 선택하는 방식.
# 시간복잡도 2^n으로 오래 걸림
# 1.가장 가치가 높은 순서로/가장 가치가 낮은 순서로/무게당 가치가 가장 높은 순서대로 담는다
# 셋 다 탐욕적인 방법으로 최적해 구하기가 어렵다.
# 회의가 가장 많이 개최되도록 하는 방법?
# 공집합이 아닌 하위 문제(subproblem)이 존재하고, 종료시간이 가장 빠른 회의를 선택한 뒤에
# 나머지 중에서  가장 빠른 회의A1의 종료시간보다 빠른 시작시간을 갖는 활동을 모두 제거한다
# 제거한 것들 중에서 종료시간이 가장 빠른 회의 A2를 선택한다.
# 이상을 반복한다.
# A : 활동집합 , S : 선택한 활동집합 , Si :시작시간, fi :종료시간
# fi 기준으로 정렬 / 가장 빠른 하나를 선택 / 선택한 활동 종료시간보다 일찍 시작하는 회의 전부 제외/반복


# 복습
# ---------------
# 부분집합 - 배낭 짐싸기와 같은 유형은 그리디하게 풀 수 없음
# 최대 무게 W n개의 물건. 이것을 넣을까 말까를 각 리스트 안 요소 별로 0/1로 표현한다.
# 원소 n개만큼을 각 for문으로 표현하는 기초적인 방법이 가능함.
# 바이너리 카운팅 - 원소 수에 해당하는 N개의 비트열을 이용함. 0/1로 부분집합에 포함되었는지를 판단함.
# 1. 부분집합 재귀호출 구현 알고리즘
# def f(i,k):
#     if i == k:
#         print(*bit)
#     else:
#         bit[i] = 0
#         f(i+1,k)
#         bit[i] = 1
#         f(i+1,k)
# A = [7,2,5,3,4]
# N = len(A)
# bit = [0] * N #bit[i] A[i]원소가 부분집합에 포함되는지를 표시함.
# f(0,N)
# 2. 바이너리 카운팅 부분집합 코드
# -----------------
# 조합
# -----------------
# 그리디 알고리즘
# ex)매 경우마다 최적으로 여겨지는 것을 선택해나가면서 결론에 도달하는 방식. 문제 전체적인 부분에서 최적인지는 알 수 없다.
#knapsack 문제 -> 한도 무게 W이하에서, 부분집합의 value총합이 가장 크게 하는 경우
#1. 부분집합을 모두 구하는 완전 탐색의 경우 / 부분집합의 총무게가 W를 초과하면 버리고, 나머지 집합들에서 sum이 가장 큰 집합을 선택함, 물건의 갯수가 증가했을 때에, 시간복잡도가 지수적으로 2^n하게 증가함.
#knapsack을 그리디하게 풀어보기 - 1.가치/무게 해서 가성비를 비교하고, 가성비가 가장 좋은 녀석부터 담는다. 2.무게가 가장 가벼운 것부터 담는다. 3.가치가 가장 높은 것부터 담는다.
#셋 다 자르거나 분리가 불가능한 0-1 knapsack에서는 전부 최적값을 내기가 어렵고, 분리가 가능한 fractional knapsack에서는 가성비가 해답이 될 수 있다.
# -----------------
# 회의 배정 문제
# -----------------
# 그리디 알고리즘 과 동적 계획법의 차이
# DP는 하위 문제 해결부터 시작해서 반복적으로 올린다. bottom-up
# -----------------
# 그리디 알고리즘으로 해결하는 베이비진 문제
# 제시되는 수를 count = [0]*len(int(input()))에 집어넣으면서 연속된다면, 같은 숫자가 3회이상이라면, 각 경우에 맞는 수를 출력
# if run + tri == 2: print('baby_gin')
# else: print('you_lose')